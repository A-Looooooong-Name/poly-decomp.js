<!DOCTYPE html>
<html>
<head>
    <title>poly-decomp.js</title>
    <style>
        * {
            margin:0;
            padding:0;
            -webkit-touch-callout: none; /* iOS Safari */
            -webkit-user-select: none;   /* Chrome/Safari/Opera */
            -khtml-user-select: none;    /* Konqueror */
            -moz-user-select: none;      /* Firefox */
            -ms-user-select: none;       /* Internet Explorer/Edge */
            user-select: none;           /* Non-prefixed version, currently not supported by any browser */
        }
        body {
            margin: 0px;
            padding: 0px;
            overflow: hidden;
            font: 13px Helvetica, arial, freesans, clean, sans-serif;
        }
        p, h1 {
            margin-bottom: 5px;
        }
        h1 a {
            text-decoration: none;
        }
        a {
            color: black;
            text-decoration: underline;
        }
        #info {
            display: block;
            background-color:#eee;
            padding:10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1><a href="https://github.com/schteppe/poly-decomp.js">poly-decomp.js</a></h1>
        <p>Decomposition of 2D polygons into convex pieces in JavaScript. See the <a href="https://github.com/schteppe/poly-decomp.js">Github repo</a>.</p>
        <p>Try drawing a polygon below!</p>
    </div>

    <script src="build/decomp.js"></script>
    <script src="dat.gui.js"></script>
    <script>
    var path = [],
        polys = [],
        reflexVertices = [],
        steinerPoints = [],
        mousedown = false,
        colors = ["#f99","#9f9","#99f","#ff9"];

    var canvas = document.createElement('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.append(canvas);

    function render() {
        var c = canvas.getContext('2d');

        // clear
        c.clearRect(0, 0, canvas.width, canvas.height);

        c.fillStyle = "red";
        c.strokeStyle = "black";

        // draw the current path
        c.beginPath();
        for(var i=0; i<path.length-1; i++){
            c.moveTo(path[i][0],path[i][1]);
            c.lineTo(path[i+1][0],path[i+1][1]);
        }
        c.fill();
        c.stroke();

        if(mousedown){
            c.beginPath();
            for(var i=0; i<path.length-1; i++){
                var p = path[i];
                c.moveTo(p[0],p[1]);
                c.arc(p[0],p[1],2,0,2*Math.PI);
            }
            c.fill();
        }

        // Draw convex polygons
        for(var i=0; i<polys.length; i++){
            c.fillStyle = colors[i%(colors.length)];
            var poly = polys[i];
            c.beginPath();
            var p = poly[0];
            c.moveTo(p[0],p[1]);
            for(var j=0; j<poly.length; j++){
                var p = poly[j];
                c.lineTo(p[0],p[1]);
            }
            c.closePath();
            c.fill();
            c.stroke();
        }

        // Draw points
        c.fillStyle = "black";
        for(var i=0; i<polys.length; i++){
            var poly = polys[i];
            c.beginPath();
            for(var j=0; j<poly.length; j++){
                var p = poly[j];
                c.moveTo(p[0],p[1]);
                c.arc(p[0],p[1],2,0,2*Math.PI);
            }
            c.fill();
        }

        if(!mousedown){
            // Draw reflex vertices
            c.fillStyle = "blue";
            c.beginPath();
            for(var j=0; j<reflexVertices.length; j++){
                var p = reflexVertices[j];
                c.moveTo(p[0],p[1]);
                c.arc(p[0],p[1],4,0,2*Math.PI);
            }
            c.fill();

            // Draw steiner points
            c.fillStyle = "red";
            c.beginPath();
            for(var j=0; j<steinerPoints.length; j++){
                var p = steinerPoints[j];
                c.moveTo(p[0],p[1]);
                c.arc(p[0],p[1],4,0,2*Math.PI);
            }
            c.fill();

            // draw point indices
            c.font = "10px Arial";
            c.fillStyle = "black";
            for(var i=0; i<path.length; i++){
                var p = path[i];
                c.fillText(i,p[0]+3,p[1]+3);
            }
        }
    }
    render();

    // Setup GUI
    var settings = {
        minEdgeLength : 50,
        quickDecomp : true,
        removeCollinear:true,
        collinearThreshold:0.001,
    };
    var gui = new dat.GUI();
    gui.add(settings, 'minEdgeLength', 1, 100);
    gui.add(settings, 'quickDecomp');
    gui.add(settings, 'removeCollinear');
    gui.add(settings, 'collinearThreshold',0,Math.PI/4);

    function getMousePos(e){
        var offset = e.target.getBoundingClientRect();
        return [e.clientX - offset.left,e.clientY - offset.top];
    }

    function sqdist(a,b){
        var dx = b[0] - a[0];
        var dy = b[1] - a[1];
        return dx * dx + dy * dy;
    }

    canvas.addEventListener('mousedown', function(e){
        path.length = 0;
        polys.length = 0;
        reflexVertices.length = steinerPoints.length = 0;
        path.push(getMousePos(e));
        mousedown = true;
        render();
    });
    canvas.addEventListener('mousemove', function(e){
        if(mousedown){
            var point = getMousePos(e),
                lengthSquared = sqdist(point,path[path.length-1]);
                minLengthSquared = settings.minEdgeLength*settings.minEdgeLength;
            if(lengthSquared > minLengthSquared){
                path.push(point);
                render();
            }
        }
    });

    function setPath(p){
        mousedown = false;
        polys.length=0;
        reflexVertices.length = steinerPoints.length = 0;
        path = p;
        if(p.length > 3){
            if(decomp.isSimple(p)){
                if(decomp.makeCCW(p)){
                    console.log("The polygon is not counter-clockwise. Reversing it...");
                }
                
                if(settings.removeCollinear){
                    console.log("Removing collinear points...");
                    decomp.removeCollinearPoints(p, settings.collinearThreshold);
                }
                console.log("setPath(["+ p.map(function(point,i){
                    return "[" + point.toString() + "/*" + i +"*/]";
                }).join(",")+"])");

                console.log("Decomposing polygon of size "+p.length+"...");
                if(settings.quickDecomp){
                    decomp.quickDecomp(p,polys,reflexVertices,steinerPoints,25,100,0,p);
                } else
                    polys = decomp.decomp(p);
                console.log("Got "+polys.length+" convex polygons. Done.");

            } else {
                console.log("The polygon was not simple. Aborting...");
            }
        }
        render();
    }

    canvas.addEventListener('mouseup', function(e){
        setPath(path);
    });

    </script>
</body>
</html>
